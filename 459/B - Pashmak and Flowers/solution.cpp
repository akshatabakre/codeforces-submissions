/*Template Author - Akshata*/#include<bits/stdc++.h>using namespace std;#define int long long const int maxN = 1000001;int spf[maxN]; // Kth Smallest/Rank using Segment Tree for a fixed range of values// Supports add(x), remove(x), findkth(k), rankOf(x)// USAGE: KthSmallestSegmentTree st(min_val, max_val);class KthSmallestSegmentTree {public:    struct Node {        int count;        Node(int m = 0) : count(m) {}    };     std::vector<Node> tree;    int range_size, value_offset;     // Initialize for values in [min_val, max_val]    KthSmallestSegmentTree(int min_val, int max_val) {        if (min_val > max_val) throw std::invalid_argument("min_val cannot be greater than max_val");        value_offset = -min_val;        range_size = max_val - min_val + 1;        tree.resize(4 * range_size);    }     Node merge(const Node& a, const Node& b) {        return Node(a.count + b.count);    }     void add(int v) {        add_recursive(1, v + value_offset, 0, range_size - 1);    }     void remove(int v) {        remove_recursive(1, v + value_offset, 0, range_size - 1);    }     // Find the k-th smallest element (1-indexed)    int findkth(int k) {        int total_elements = tree[1].count;        if (total_elements == 0) throw std::runtime_error("Cannot find kth element in an empty tree");        k = (k > total_elements) ? total_elements : (k < 1 ? 1 : k);        return findkth_recursive(1, 0, range_size - 1, k) - value_offset;    }     // Count of elements <= v    int rankOf(int v) {        int val_idx = v + value_offset;        if (val_idx < 0) return 0;        if (val_idx >= range_size) return tree[1].count;        return rank_recursive(1, 0, range_size - 1, 0, val_idx);    } private:    void add_recursive(int i, int v_idx, int l, int r) {        if (l == r) {            tree[i].count++;            return;        }        int m = l + (r - l) / 2;        if (v_idx <= m) {            add_recursive(2 * i, v_idx, l, m);        } else {            add_recursive(2 * i + 1, v_idx, m + 1, r);        }        tree[i] = merge(tree[2 * i], tree[2 * i + 1]);    }     void remove_recursive(int i, int v_idx, int l, int r) {        if (l == r) {            if (tree[i].count > 0) tree[i].count--;            return;        }        int m = l + (r - l) / 2;        if (v_idx <= m) {            remove_recursive(2 * i, v_idx, l, m);        } else {            remove_recursive(2 * i + 1, v_idx, m + 1, r);        }        tree[i] = merge(tree[2 * i], tree[2 * i + 1]);    }     int findkth_recursive(int i, int l, int r, int k) {        if (l == r) return l;        int m = l + (r - l) / 2;        if (k <= tree[2 * i].count) {            return findkth_recursive(2 * i, l, m, k);        }        return findkth_recursive(2 * i + 1, m + 1, r, k - tree[2 * i].count);    }     int rank_recursive(int i, int l, int r, int ql, int qr) {        if (l > qr || r < ql) return 0;        if (ql <= l && r <= qr) return tree[i].count;        int m = l + (r - l) / 2;        return rank_recursive(2 * i, l, m, ql, qr) + rank_recursive(2 * i + 1, m + 1, r, ql, qr);    }}; void pre() {    for(int i = 0; i < maxN; i++) { spf[i] = i; }    for(int i = 2; i * i < maxN; i++) {        if(spf[i] == i) {            for(int j = i * i; j < maxN; j += i) {                if(spf[j] == j) spf[j] = i;            }        }    }} void inparr(vector<int>&a, int n) { for(int i = 0; i < n; i++) { cin >> a[i]; } } void solve() {    int n; cin >> n;    vector<int> v(n);    inparr(v,n);    int mini=1e9, minf=0, maxi=-1e9, maxf=0;    for(int i:v){        if(mini>i){            minf=1;            mini=i;        }else if(mini==i){            minf++;        }        if(maxi<i){            maxf = 1;            maxi = i;        }else if(maxi==i){            maxf++;        }    }    if(mini==maxi){        cout<<0<<" "<<maxf*(maxf-1)/2<<endl;        return;    }    cout<<maxi-mini<<" "<<maxf*minf<<endl;} int32_t main() {    ios_base::sync_with_stdio(false);    cin.tie(NULL);     // pre(); // Uncomment for Sieve     int t = 1;    // cin >> t;    while(t--) {        solve();    }     return 0;}