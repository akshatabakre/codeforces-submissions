/*Template Author - Akshata*/#include<bits/stdc++.h>using namespace std;#define int long long const int maxN = 1000001;int spf[maxN]; // Kth Smallest/Rank using Segment Tree for fixed range valuesclass KthSmallestSegmentTree{public:const long long MIN_VAL=-1e9,MAX_VAL=1e9;struct Node{int count=0;Node*l=nullptr,*r=nullptr;};Node*root=new Node();void add(int v){add_recursive(root,MIN_VAL,MAX_VAL,v);} void remove(int v){remove_recursive(root,MIN_VAL,MAX_VAL,v);} int findkth(int k){int t=root->count;if(t==0)throw runtime_error("E");k=k>t?t:k<1?1:k;return findkth_recursive(root,MIN_VAL,MAX_VAL,k);} int rankOf(int v){return rank_recursive(root,MIN_VAL,MAX_VAL,v-1);}void add_recursive(Node*&curr,long long l,long long r,int v){if(!curr)curr=new Node();curr->count++;if(l==r)return;long long m=l+(r-l)/2;if(v<=m)add_recursive(curr->l,l,m,v);else add_recursive(curr->r,m+1,r,v);}void remove_recursive(Node*curr,long long l,long long r,int v){if(!curr)return;curr->count--;if(l==r)return;long long m=l+(r-l)/2;if(v<=m)remove_recursive(curr->l,l,m,v);else remove_recursive(curr->r,m+1,r,v);}int findkth_recursive(Node*curr,long long l,long long r,int k){if(l==r)return l;int lc=curr->l?curr->l->count:0;if(k<=lc)return findkth_recursive(curr->l,l,l+(r-l)/2,k);return findkth_recursive(curr->r,l+(r-l)/2+1,r,k-lc);} int rank_recursive(Node*curr,long long l,long long r,int qr){if(!curr||qr<l)return 0;if(r<=qr)return curr->count;long long m=l+(r-l)/2;return rank_recursive(curr->l,l,m,qr)+rank_recursive(curr->r,m+1,r,qr);}}; void pre(){for(int i=0;i<maxN;i++)spf[i]=i;for(int i=2;i*i<maxN;i++)if(spf[i]==i)for(int j=i*i;j<maxN;j+=i)if(spf[j]==j)spf[j]=i;}void inparr(vector<int>&a,int n){for(int i=0;i<n;i++)cin>>a[i];} void solve(){    int n;    cin>>n;    vector<vector<int>> edges(n-1,vector<int>(2));    vector<int> order(n+1,0);    vector<int> ans(n-1);    for(int i=0;i<n-1;i++){        cin>>edges[i][0]>>edges[i][1];        if(edges[i][0]>edges[i][1]){            swap(edges[i][0],edges[i][1]);        }        order[edges[i][0]]++;        order[edges[i][1]]++;    }    int x = -1;    for(int i=1;i<=n;i++){        if(order[i]>2){            x = i;            break;        }    }    if(x==-1){        for(int i=0;i<n-1;i++)        {            cout<<i<<endl;        }    }else{        int sm = 0;        for(int i=0;i<n-1;i++){            if(edges[i][0]==x || edges[i][1]==x){                ans[i] = sm;                sm++;            }        }        for(int i=0;i<n-1;i++){            if(ans[i]==0 && (edges[i][0]!=x && edges[i][1]!=x)){                ans[i] = sm;                sm++;            }        }        for(int i=0;i<n-1;i++){            cout<<ans[i]<<endl;        }    }} int32_t main(){ios_base::sync_with_stdio(false);cin.tie(NULL);// pre(); // Uncomment for Sieveint t=1;while(t--)solve();return 0;}